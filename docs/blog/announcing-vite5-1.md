---
title: Доступен Vite 5.1!
author:
  name: The Vite Team
date: 2024-02-08
sidebar: false
head:
  - - meta
    - property: og:type
      content: website
  - - meta
    - property: og:title
      content: Анонс Vite 5.1
  - - meta
    - property: og:image
      content: https://vite.dev/og-image-announcing-vite5-1.png
  - - meta
    - property: og:url
      content: https://vite.dev/blog/announcing-vite5-1
  - - meta
    - property: og:description
      content: Анонс выпуска Vite 5.1
  - - meta
    - name: twitter:card
      content: summary_large_image
---

# Доступен Vite 5.1! {#vite-5-1-is-out}

_8 февраля 2024_

![Обложка объявления Vite 5.1](/og-image-announcing-vite5-1.png)

Vite 5 [был выпущен](./announcing-vite5.md) в ноябре, и это стало ещё одним большим шагом вперёд для Vite и экосистемы. Несколько недель назад мы отметили 10 миллионов загрузок npm в неделю и 900 участников в репозитории Vite. Сегодня мы рады объявить о выпуске Vite 5.1.

Быстрые ссылки: [Документация](/), [Изменения](https://github.com/vitejs/vite/blob/main/packages/vite/CHANGELOG.md#510-2024-02-08)

Документация на других языках: [English](https://vite.dev), [简体中文](https://cn.vite.dev/), [日本語](https://ja.vite.dev/), [Español](https://es.vite.dev/), [Português](https://pt.vite.dev/), [한국어](https://ko.vite.dev/), [Deutsch](https://de.vite.dev/)

Попробуйте Vite 5.1 онлайн в StackBlitz: [vanilla](https://vite.new/vanilla-ts), [vue](https://vite.new/vue-ts), [react](https://vite.new/react-ts), [preact](https://vite.new/preact-ts), [lit](https://vite.new/lit-ts), [svelte](https://vite.new/svelte-ts), [solid](https://vite.new/solid-ts), [qwik](https://vite.new/qwik-ts).

Если вы новичок в Vite, мы рекомендуем сначала прочитать руководства [Начало работы](/guide/) и [Возможности](/guide/features).

Чтобы быть в курсе событий, следите за нами в [X](https://x.com/vite_js) или [Mastodon](https://webtoo.ls/@vite).

## Vite Runtime API {#vite-runtime-api}

Vite 5.1 добавляет экспериментальную поддержку нового API Vite Runtime. Он позволяет выполнять любой код, предварительно обрабатывая его с помощью плагинов Vite. Это отличается от `server.ssrLoadModule`, поскольку реализация времени выполнения отделена от сервера. Это позволяет авторам библиотек и фреймворков реализовывать свой собственный уровень взаимодействия между сервером и временем выполнения. Этот новый API предназначен для замены текущих примитивов SSR Vite, как только он станет стабильным.

Новый API приносит множество преимуществ:

- Поддержка HMR во время SSR.
- Он отделен от сервера, поэтому нет ограничений на количество клиентов, которые могут использовать один сервер — у каждого клиента есть свой собственный кэш модулей (вы даже можете взаимодействовать с ним так, как хотите — используя каналы сообщений, вызовы fetch, прямые вызовы функций или веб-сокеты).
- Он не зависит от каких-либо встроенных API node/bun/deno, поэтому может работать в любой среде.
- Легко интегрируется с инструментами, которые имеют свой собственный механизм выполнения кода (например, вы можете предоставить исполнителя для использования `eval` вместо `new AsyncFunction`).

Изначальная идея [была предложена Пуйя Парса](https://github.com/nuxt/vite/pull/201) и реализована [Энтони Фу](https://github.com/antfu) в виде пакета [vite-node](https://github.com/vitest-dev/vitest/tree/main/packages/vite-node#readme) для [поддержки Dev SSR в Nuxt 3](https://antfu.me/posts/dev-ssr-on-nuxt), а позже также использовалась в качестве основы для [Vitest](https://vitest.dev). Таким образом, общая идея vite-node была протестирована в боевых условиях на протяжении довольно долгого времени. Это новая итерация API от [Владимира Шеремета](https://github.com/sheremet-va), который уже повторно реализовал vite-node в Vitest и использовал полученные знания, чтобы сделать API ещё более мощным и гибким при добавлении его в Vite Core. Подготовка PR заняла целый год, вы можете увидеть эволюцию и обсуждения с разработчиками зависящих проектов экосистемы [здесь](https://github.com/vitejs/vite/issues/12165).

::: info
Runtime API Vite эволюционировал в Module Runner API, выпущенный в Vite 6 как часть [Environment API](/guide/api-environment).

:::

## Возможности {#features}

### Улучшена поддержка `.css?url` {#improved-support-for-css-url}

Импорт CSS-файлов в виде URL теперь работает надежно и корректно. Это было последнее препятствие на пути перехода Remix в Vite. См. ([#15259](https://github.com/vitejs/vite/issues/15259)).

### `build.assetsInlineLimit` теперь поддерживает обратный вызов {#build-assetsinlinelimit-now-supports-a-callback}

Теперь пользователи могут [предоставить обратный вызов](/config/build-options.html#build-assetsinlinelimit), который возвращает булево значение для отказа или включения инлайнинга для определённых ресурсов. Если возвращается `undefined`, применяется логика по умолчанию. См. ([#15366](https://github.com/vitejs/vite/issues/15366)).

### Улучшен HMR для циклического импорта {#improved-hmr-for-circular-import}

В Vite 5.0 принимаемые модули в рамках кругового импорта всегда вызывали полную перезагрузку страницы, даже если они прекрасно обрабатывались в клиенте. Теперь это сделано для того, чтобы HMR применялся без полной перезагрузки страницы, но если во время HMR произойдет какая-либо ошибка, страница будет перезагружена. См. ([#15118](https://github.com/vitejs/vite/issues/15118)).

### Поддержка `ssr.external: true` для экстернализации всех пакетов SSR {#support-ssr-external-true-to-externalize-all-ssr-packages}

Исторически сложилось так, что Vite экстернализирует все пакеты, за исключением связанных пакетов. Эта новая опция может быть использована для принудительной экстернализации всех пакетов, включая связанные пакеты. Это удобно в тестах в рамках монорепозиториев, где мы хотим эмулировать обычный случай, когда все пакеты внешние, или когда мы используем `ssrLoadModule` для загрузки произвольного файла и хотим всегда иметь внешние пакеты, поскольку нас не волнует HMR. См. ([#10939](https://github.com/vitejs/vite/issues/10939)).

### Метод `close` в сервере предварительного просмотра {#expose-close-method-in-the-preview-server}

Сервер предварительного просмотра теперь предоставляет метод `close`, который корректно завершает работу сервера, включая все открытые сокетные соединения. См. ([#15630](https://github.com/vitejs/vite/issues/15630)).

## Улучшение производительности {#performance-improvements}

Vite продолжает становиться быстрее с каждым релизом, и Vite 5.1 наполнен улучшениями производительности. Мы измерили время загрузки для 10K модулей (дерево глубиной 25 уровней), используя [vite-dev-server-perf](https://github.com/yyx990803/vite-dev-server-perf) для всех минорных версий начиная с Vite 4.0. Это хороший бенчмарк для оценки влияния подхода Vite, основанного на отсутствии пакетов. Каждый модуль — это небольшой файл TypeScript с счётчиком и импортами в другие файлы в дереве, поэтому это в основном измеряет время, необходимое для выполнения запросов к отдельным модулям. В Vite 4.0 загрузка 10K модулей заняла 8 секунд на M1 MAX. У нас был прорыв в [Vite 4.3, когда мы сосредоточились на производительности](./announcing-vite4-3.md), и нам удалось загрузить их за 6.35 секунд. В Vite 5.1 мы смогли сделать ещё один скачок в производительности. Vite теперь обслуживает 10K модулей за 5.35 секунд.

![Прогресс времени загрузки 10K модулей Vite](/vite5-1-10K-modules-loading-time.png)

Результаты этого бенчмарка работают на Headless Puppeteer и являются хорошим способом сравнения версий. Однако они не отражают время, которое испытывают пользователи. При запуске тех же 10K модулей в приватном режиме в Chrome мы имеем:

| 10K модулей               | Vite 5.0 | Vite 5.1 |
| ------------------------- | :------: | :------: |
| Время загрузки            | 2892 мс  | 2765 мс  |
| Время загрузки (кэш)      | 2778 мс  | 2477 мс  |
| Полная перезагрузка       | 2003 мс  | 1878 мс  |
| Полная перезагрузка (кэш) | 1682 мс  | 1604 мс  |

### Запуск препроцессоров CSS в потоках {#run-css-preprocessors-in-threads}

Vite теперь имеет поддержку запуска CSS-препроцессоров в потоках по желанию. Вы можете включить это, используя [`css.preprocessorMaxWorkers: true`](/config/shared-options.html#css-preprocessormaxworkers). Для проекта на Vuetify 2 время запуска в режиме разработки было сокращено на 40% благодаря включению этой функции. Есть [сравнение производительности для других настроек в PR](https://github.com/vitejs/vite/pull/13584#issuecomment-1678827918). См. ([#13584](https://github.com/vitejs/vite/issues/13584)). [Оставьте отзыв](https://github.com/vitejs/vite/discussions/15835).

### Новые опции для улучшения холодного запуска сервера {#new-options-to-improve-server-cold-starts}

Вы можете установить `optimizeDeps.holdUntilCrawlEnd: false`, чтобы переключиться на новую стратегию оптимизации зависимостей, которая может помочь в больших проектах. Мы рассматриваем возможность переключения на эту стратегию по умолчанию в будущем. [Оставьте отзыв](https://github.com/vitejs/vite/discussions/15834). ([#15244](https://github.com/vitejs/vite/issues/15244))

### Более быстрое разрешение с помощью кэшированных проверок {#faster-resolving-with-cached-checks}

Оптимизация `fs.cachedChecks` теперь включена по умолчанию. В Windows `tryFsResolve` стал примерно в 14 раз быстрее с этой оптимизацией, а разрешение идентификаторов в целом получило примерно 5-кратное ускорение в треугольном бенчмарке. ([#15704](https://github.com/vitejs/vite/issues/15704))

### Улучшение внутренней производительности {#internal-performance-improvements}

Сервер разработки получил несколько постепенных улучшений производительности. Новое промежуточное ПО для короткого замыкания на 304 ([#15586](https://github.com/vitejs/vite/issues/15586)). Мы избегали `parseRequest` в горячих путях ([#15617](https://github.com/vitejs/vite/issues/15617)). Rollup теперь правильно загружается по требованию ([#15621](https://github.com/vitejs/vite/issues/15621)).

## Устаревания {#deprecations}

Мы продолжаем сокращать API Vite, где это возможно, чтобы сделать проект более поддерживаемым в долгосрочной перспективе.

### Утратившая актуальность опция `as` в `import.meta.glob` {#deprecated-as-option-in-import-meta-glob}

Стандарт перешёл к [атрибутам импорта](https://github.com/tc39/proposal-import-attributes), но мы не планируем заменять `as` на новую опцию на данный момент. Вместо этого рекомендуется, чтобы пользователи переключились на `query`. См. ([#14420](https://github.com/vitejs/vite/issues/14420)).

### Удалено экспериментальное предварительное объединение во время сборки {#removed-experimental-build-time-pre-bundling}

Предварительное объединение во время сборки, экспериментальная функция, добавленная в Vite 3, удалена. С переходом Rollup 4 на встроенный парсер и разработкой Rolldown, как производительность, так и несоответствие между разработкой и сборкой для этой функции больше не актуальны. Мы хотим продолжать улучшать согласованность разработки и сборки и пришли к выводу, что использование Rolldown для «предварительной сборки во время разработки» и «продакшен-сборок» является более надёжным решением на будущее. Rolldown также может реализовать кэширование таким образом, что это будет гораздо более эффективно во время сборки, чем предварительная сборка зависимостей. См. ([#15184](https://github.com/vitejs/vite/issues/15184)).

## Примите участие {#get-involved}

Мы благодарны [900 участникам Vite Core](https://github.com/vitejs/vite/graphs/contributors) и разработчикам плагинов, интеграций, инструментов и переводов, которые продолжают развивать экосистему. Если вам нравится Vite, мы приглашаем вас участвовать и помогать нам. Ознакомьтесь с нашим [Руководством по участию](https://github.com/vitejs/vite/blob/main/CONTRIBUTING.md) и присоединяйтесь к [разбору проблем](https://github.com/vitejs/vite/issues), [обзору PR](https://github.com/vitejs/vite/pulls), ответам на вопросы в [обсуждениях на GitHub](https://github.com/vitejs/vite/discussions) и помощи другим в сообществе в [Vite Land](https://chat.vite.dev).

## Благодарности {#acknowledgments}

Выпуск Vite 5.1 стал возможен благодаря нашему сообществу участников, разработчиков в экосистеме и [команде Vite](/team). Особая благодарность отдельным лицам и компаниям, спонсирующим разработку Vite. [StackBlitz](https://stackblitz.com/), [Nuxt Labs](https://nuxtlabs.com/) и [Astro](https://astro.build) за найм членов команды Vite. А также спонсорам на [GitHub Sponsors Vite](https://github.com/sponsors/vitejs), [Open Collective Vite](https://opencollective.com/vite) и [GitHub Sponsors Эвана Ю](https://github.com/sponsors/yyx990803).
